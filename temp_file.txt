import { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import { Document } from "../types";
import { getAllDocumentsFromAPI } from "../data";
import { getAccessTokenFromServer } from "@/lib/api";

const SIADIL_DOCUMENTS_KEY = "siadil_documents_storage";
const SIADIL_DOCUMENTS_FETCHED_KEY = "siadil_documents_fetched";

// üî• GLOBAL FLAG: Prevent multiple simultaneous fetches
let isFetchingDocuments = false;
let documentsCache: Document[] | null = null;

/**
 * üî• Helper function: Deduplicate documents by ID
 * Saat merge regular + reminder documents, ada kemungkinan dokumen yang sama
 * Fungsi ini akan ambil unique documents berdasarkan ID
 * 
 * @param docs - Array of documents (may contain duplicates)
 * @returns Array of unique documents
 */
function deduplicateDocuments(docs: Document[]): Document[] {
  const uniqueDocsMap = new Map<string, Document>();
  
  docs.forEach((doc) => {
    const docId = String(doc.id);
    if (!uniqueDocsMap.has(docId)) {
      uniqueDocsMap.set(docId, doc);
    } else {
      // Jika duplicate, prefer document dengan expireDate (dari reminder API)
      const existingDoc = uniqueDocsMap.get(docId);
      if (existingDoc && doc.expireDate && !existingDoc.expireDate) {
        uniqueDocsMap.set(docId, doc);
      }
    }
  });
  
  return Array.from(uniqueDocsMap.values());
}

export function usePersistentDocuments(): [
  Document[],
  React.Dispatch<React.SetStateAction<Document[]>>,
  {
    isLoading: boolean;
    error: Error | null;
    loadingProgress: {
      loaded: number;
      total: number;
      percentage: number;
    } | null;
  }
] {
  const { data: session } = useSession();
  const [documents, setDocuments] = useState<Document[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [loadingProgress, setLoadingProgress] = useState<{
    loaded: number;
    total: number;
    percentage: number;
  } | null>(null);

  // üî• FIX: Prevent double fetch dengan useRef
  const hasFetchedRef = useRef(false);
  const isMountedRef = useRef(true);

  useEffect(() => {
    // üî• Cleanup function untuk set unmounted flag
    isMountedRef.current = true;

    async function loadDocuments() {
      try {
        console.log("üîÑ usePersistentDocuments - Starting load...");
        console.log("üîë Session available:", !!session);
        console.log(
          "üîë Session Access token:",
          session?.accessToken ? "YES ‚úÖ" : "NO ‚ùå"
        );

        // üî• FIX: Cek jika sudah pernah fetch, jangan fetch lagi
        if (hasFetchedRef.current) {
          console.log("‚ö†Ô∏è Documents already fetched, skipping...");
          setIsLoading(false);
          return;
        }

        // üî• FIX: Cek jika sedang fetching, tunggu atau skip
        if (isFetchingDocuments) {
          console.log("‚ö†Ô∏è Documents fetch already in progress, skipping...");
          setIsLoading(false);
          return;
        }

        // üî• FIX: Jika ada cache dan belum expired, gunakan cache
        if (documentsCache && documentsCache.length > 0) {
          console.log("‚úÖ Using cached documents:", documentsCache.length);
          setDocuments(documentsCache);
          setIsLoading(false);
          hasFetchedRef.current = true;
          return;
        }

        // Tunggu sampai session ada (user sudah login)
        if (session) {
          console.log("üì° Fetching documents from API...");

          // üî• Set flag: sedang fetching
          isFetchingDocuments = true;

          // Fetch token dari server-side API route
          console.log("üîë Trying to get token from server API...");
          const tokenFromServer = await getAccessTokenFromServer();

          console.log(
            "üîë Token from server API:",
            tokenFromServer ? "EXISTS ‚úÖ" : "NULL ‚ùå"
          );

          // Gunakan token dari server, fallback ke session token
          const accessToken = tokenFromServer || session.accessToken;

          if (!accessToken) {
            console.error("‚ùå No access token available");
            setDocuments([]);
            setIsLoading(false);
            return;
          }

          console.log("üîë Using token:", accessToken.substring(0, 30) + "...");
          console.log("üåê API will be called with token");
          console.log(
            "üîÑ Using PAGINATION system to fetch ALL documents (800 per page)..."
          );
          console.log(
            "‚ú® Progressive Loading ENABLED - Data akan langsung tampil setiap page!"
          );

          console.log("üîó Merging regular + reminder documents...");
          const combinedDocuments = [...regularDocuments, ...reminderDocuments];
          const apiDocuments = deduplicateDocuments(combinedDocuments);
          
          console.log("üìä Merge Summary:");
          console.log(`   - Regular documents: ${regularDocuments.length}`);
          console.log(`   - Reminder documents: ${reminderDocuments.length}`);
          console.log(`   - Combined (before dedup): ${combinedDocuments.length}`);
          console.log(`   - Final (after dedup): ${apiDocuments.length}`);

          // üî• FIX: Cek jika component sudah unmounted
          if (!isMountedRef.current) {
            console.log("‚ö†Ô∏è Component unmounted during fetch, aborting...");
            isFetchingDocuments = false;
            return;
          }

          console.log(`üìä Documents Summary:`);
          console.log(`   - Total documents fetched: ${apiDocuments.length}`);

          // üî• FIX: Simpan ke cache
          documentsCache = apiDocuments;

          // üîç DEBUG: Cek berapa dokumen yang punya expireDate
          const docsWithExpireDate = apiDocuments.filter(
            (d) => d.expireDate && d.expireDate !== ""
          );
          const docsExpired = apiDocuments.filter((d) => d.documentExpired);
          const docsExpiringSoon = apiDocuments.filter(
            (d) =>
              !d.documentExpired &&
              d.daysUntilExpire !== null &&
              d.daysUntilExpire !== undefined &&
              d.daysUntilExpire <= 30 &&
              d.daysUntilExpire >= 0
          );

          console.log(
            "   - Documents with expireDate:",
            docsWithExpireDate.length,
            `(${(
              (docsWithExpireDate.length / apiDocuments.length) *
              100
            ).toFixed(1)}%)`
          );
          console.log("   - Documents expired:", docsExpired.length);
          console.log(
            "   - Documents expiring soon (<=30 days):",
            docsExpiringSoon.length
          );

          if (docsWithExpireDate.length > 0) {
            console.log("   - ‚úÖ Sample docs with expire:");
            docsWithExpireDate.slice(0, 3).forEach((doc, idx) => {
              console.log(
                `      ${idx + 1}. "${doc.title?.substring(0, 40)}" ‚Üí Expire: ${
                  doc.expireDate
                }, Expired: ${doc.documentExpired}, Days: ${
                  doc.daysUntilExpire
                }`
              );
            });
          } else {
            console.warn("   ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è NO DOCUMENTS HAVE EXPIRE DATE! ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è");
            console.warn(
              "   This means API didn't return document_expire_date field"
            );
            console.warn("   OR all documents have NULL/empty expire dates");
            console.warn("   Sample document structure:");
            if (apiDocuments.length > 0) {
              console.log("   Fields:", Object.keys(apiDocuments[0]));
            }
          }

          // üî• Progressive loading sudah update UI setiap page
          // Di sini hanya perlu save final state ke localStorage (SEKALI SAJA!)
          const currentDocs = documents.length > 0 ? documents : apiDocuments;

          // üî• FIX: Save to localStorage dengan error handling untuk quota exceeded
          try {
            // Simpan hanya essential data untuk mengurangi size
            const essentialDocs = currentDocs.map((doc) => ({
              id: doc.id,
              isStarred: doc.isStarred,
              lastAccessed: doc.lastAccessed,
            }));

            // Save essential data saja (lebih kecil)
            localStorage.setItem(
              SIADIL_DOCUMENTS_KEY,
              JSON.stringify(essentialDocs)
            );
            localStorage.setItem(SIADIL_DOCUMENTS_FETCHED_KEY, "true");
            console.log(
              `üíæ Saved ${essentialDocs.length} documents metadata to localStorage`
            );
          } catch {
            // üî• Handle localStorage quota exceeded
            console.warn(
              "‚ö†Ô∏è Failed to save to localStorage (quota exceeded or full)"
            );
            console.warn("   Data will be fetched from API on next load");

            // Try to clear old data and save again
            try {
              console.log("üßπ Clearing old localStorage data...");
              localStorage.removeItem(SIADIL_DOCUMENTS_KEY);
              localStorage.removeItem(SIADIL_DOCUMENTS_FETCHED_KEY);

              // Try minimal save
              const minimalDocs = currentDocs.map((doc) => ({
                id: doc.id,
                isStarred: doc.isStarred || false,
              }));
              localStorage.setItem(
                SIADIL_DOCUMENTS_KEY,
                JSON.stringify(minimalDocs)
              );
              console.log("‚úÖ Saved minimal documents metadata after cleanup");
            } catch {
              console.warn("‚ùå Still cannot save to localStorage, skipping...");
              // Tidak masalah, data tetap ada di memory (documents state)
            }
          }

          console.log(
            `‚úÖ ALL Documents loaded complete! Total: ${apiDocuments.length} items`
          );
          console.log(`‚ú® UI updated progressively during loading`);

          // üî• FIX: Mark as fetched dan reset flag
          hasFetchedRef.current = true;
          isFetchingDocuments = false;
          setIsLoading(false);
        } else {
          console.log("‚è≥ No session yet, waiting for login...");
          console.log("   - Documents will be loaded after login");
          setDocuments([]);
          setIsLoading(false);
        }
      } catch (error) {
        console.error("‚ùå Error loading documents:", error);
        if (error instanceof Error) {
          console.error("   - Error message:", error.message);
          console.error("   - Error stack:", error.stack);
          setError(error);
        } else {
          setError(new Error("Unknown error occurred"));
        }
        console.log("‚ö†Ô∏è Documents cannot be loaded - API error");

        // üî• FIX: Reset flags on error
        isFetchingDocuments = false;
        hasFetchedRef.current = false;
        documentsCache = null;

        setDocuments([]);
        setIsLoading(false);
      }
    }

    loadDocuments();

    // üî• FIX: Cleanup function
    return () => {
      console.log("üßπ usePersistentDocuments - Cleanup");
      isMountedRef.current = false;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [session]); // Only run when session changes

  // üî• OPTIMIZED: Save only essential user data (isStarred, lastAccessed) to localStorage
  // Tidak save full documents untuk avoid quota exceeded
  useEffect(() => {
    if (!isLoading && documents.length > 0) {
      try {
        // Simpan hanya data yang dimodifikasi user (isStarred, lastAccessed)
        const essentialData = documents
          .filter((doc) => doc.isStarred || doc.lastAccessed) // Hanya doc yang ada user interaction
          .map((doc) => ({
            id: doc.id,
            isStarred: doc.isStarred,
            lastAccessed: doc.lastAccessed,
          }));

        if (essentialData.length > 0) {
          localStorage.setItem(
            SIADIL_DOCUMENTS_KEY,
            JSON.stringify(essentialData)
          );
          console.log(
            `üíæ Saved ${essentialData.length} user interactions to localStorage`
          );
        }
      } catch {
        console.warn("‚ö†Ô∏è Failed to save user interactions to localStorage");
        // Tidak masalah, data tetap ada di memory
      }
    }
  }, [documents, isLoading]);

  return [documents, setDocuments, { isLoading, error, loadingProgress }];
}
